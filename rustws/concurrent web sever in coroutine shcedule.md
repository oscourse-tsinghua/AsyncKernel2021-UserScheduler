# 一、 调度器架构

![](/Users/wangwenzhi/Library/Application%20Support/marktext/images/2021-11-25-22-45-33-image.png)

协程调度器在用户态运行，为了支持协程运行，会创建若干内核线程运行于物理核之上，每个线程执行相同的函数`thread_main()`，作用是在一个loop中不断访问调度器，取出协程执行，如果协程主动让出，则插回调度器，取出下一个协程执行。

将此调度器应用于服务器处理并发网络请求的场景，只需将一个网络请求的处理过程：`get request` —> `calculate` —> `send responce`封装进协程。



# 二、 调度算法设计

处理一个网络请求分为三步：`get request`，`caculate`，`send responce`，第一步是异步读取网络流，所需要的内容有可能不会马上被读到，这个操作会主动让出。考虑队列中所有的协程，第1个到第n个，每一个协程处理请求执行第一步时，都有可能主动让出1次、2次、3次...，那么先执行到的协程，在它主动让出之后，认为它会比后续将要取出的协程更有可能更早得完成第一步异步读取网络流，所以协程主动让出之后应该升高优先级，使其更快地被访问到。

但是，调度器每次取出优先级最高的协程执行，如果协程主动让出之后升高其优先级，那么cpu就会不断地原地轮训先取出的协程，也就是同步、顺序处理到达的请求队列，这是效率非常低的做法，需要做出进一步修改。

为了避免升高优先级之后CPU的原地等待，调度器不再总是取出优先级最高的协程，只有当`最高优先级队列长度 > 阈值 || 所有协程都是相同优先级`才从最高优先级队列取走协程，否则，取出次优先级的协程。



# 三、性能测试

## 3.1 MacOS

### 示例程序最好情况

![](/Users/wangwenzhi/Library/Application%20Support/marktext/images/2021-11-25-23-52-34-image.png)

### 协程调度器最好情况

![](/Users/wangwenzhi/Library/Application%20Support/marktext/images/2021-11-25-23-53-29-image.png)

## 3.2 centOS

### 示例程序最好情况

![](/Users/wangwenzhi/Library/Application%20Support/marktext/images/2021-11-25-23-57-14-image.png)

### 协程调度器最好情况

![](/Users/wangwenzhi/Library/Application%20Support/marktext/images/2021-11-25-23-56-34-image.png)



## 总结与分析

示例程序的做法是，为每一个到达的网络请求，创建一个线程去处理，而协程调度器的做法是用一个线程去处理多个请求，当并发数高时，理论上前一种做法将造成大量的线程创建、切换开销，但在centos上测试结果显示并发数到达2000后，依然是示例程序快（未测得macos的高并发结果，因未知原因macos无法发送高并发请求）。

但值得注意的是，示例程序的多线程处理网络请求的做法，增大并发量之后丢包率非常高，但协程调度器（几乎）不存在丢包的情况。

除了协程调度器的性能瓶颈问题之外，还有一个值得注意的问题是，协程调度器除了网络请求，在centos和macos的不同的环境下，表现出极大的性能差距，而示例程序在macos和centos的环境下都能跑出很高的效率。

研究示例程序所使用的`smol`库或许会有收获！


