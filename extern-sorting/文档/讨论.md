## 20210717 讨论

### 统一调度器的设计

1. block_on函数创建为线程，其内部运行、调度协程，可以实现线程与协程的统一调度.
2. 改进future::join函数，先轮询所有future的状态，再决定执行哪个future，或yield到另一个线程.

### 写程序验证设计

. 1. 把两个200行合到一起，多个协程可以封装到一个green线程中；每个协程输出线程和协程的ID、当前时间、自己的字符串（行号和函数名）；这时的表现是，内层循环是协程，外层循环是线程；（一天）
2. 在poll中加yield：内层循环是线程，外层循环是协程；（一天）

3. 每个线程和协程都有一个控制块数据结构（修改数据结构，用启动参数来指定优先级）；这时的表现是，每次输出多上一个优先级；（一天）

4. 依据优先级条件的不同，选择性地加yield：按优先级执行；这时的表现是，所有协程按优先级执行；（一天）



## 20210716 统一调度器问题

![](https://github.com/oscourse-tsinghua/AsyncKernel2021-UserScheduler/blob/master/extern-sorting/文档/image/202107161.png)

### greenthread和reactor

为了使调度器能控制每个线程的调度，应该将底层线程根据greenthread中的Runtime封装为绿色线程；为了使读、写协程可以并发执行，应该保留reactor。

所以程序应该结合Runtime和reactor。reactor负责接收协程发送过来的事件，创建对应的函数，**将其创建为Runtime中的线程**（相当于内核线程的join）,交给Runtime调度。

Runtime中的线程只能在同一个cpu上运行，本质上就是Runtime中的各个线程，根据其调度，不断地切换该cpu的执行环境，以执行不同的线程（函数）。

### 统一调度

线程 = 一段代码 + 执行期间的上下文 + 所需资源。用一个数据结构描述，就是保存一个函数，以及此函数执行的上下文环境的结构体。

如果（可以）将协程封装为同一结构，那么调度器就可以进行统一调度。但是，将协程封装为与线程一样的结构，在开销上，协程将与线程一致。**统一调度器的目标是，既能保存协程的轻量切换，也能将其与线程统一调度。**

统一调度器的目标或许不能通过统一协程和线程的数据结构来实现。但是，协程的执行必须使用excutor（或.await），如果将excutor（协程的future作为其参数）封装为线程，相当于，将所有的协程封装进一个大协程，这个大协程会去依次执行每个协程的poll函数，然后将大协程作为excutor的参数，将excutor封装为线程。

问题：

如果将excutor封装为线程，其内部各个协程的切换是否是轻量切换？是否能达到目标？





## 20210707

最底层的读文件线程在读取一个buffer之后，需要将结果传递给上层线程，这个结果作为函数参数传入线程。原先的做法是将读出的结果赋值给此参数，现在将此参数改为一个指针，取出读出的结果指针进行赋值，使得效率显著提升。

在多协程读中，一次性生成所有读线程，虽然CPU数量有限，但在未读完时可以使CPU一直满载，相比于多次生成少量读线程，提高了吞吐率。

|                        | 多协程读                             | 无协程读 |
| ---------------------- | ------------------------------------ | -------- |
| 读buffer大小           | 1MB                                  | 1MB      |
| 程序总体完成时间       | 0.21S                                | 0.35S    |
| 完成一次读操作所需时间 | 最开始为0.002S，然后为0.0003-0.0008S | 0.0002S  |

多协程读，完成一次读操作的时间更慢，是因为每个读线程都需要打开文件并设置读的位置。且虽然改进了读出结果向上层传递的做法，但这个操作依然比不需要传递的情况更耗时。



## 20210703

### 结果分析

- 数据量大小: sor1.txt --1.04G, sort2.txt --1.44G。
- 对于执行结果比较稳定的情况，使用 0.97-1.17 表示；不稳定的情况使用三行数字表示，第一行为最好情况，第三行为最坏情况，中间一行为出现次数最多的情况。
- 从实际执行结果来看，并不是读的块越大，读文件的性能就越好，单次读到达64M后，多协程读和单线程读的速度都开始下降。
- 协程的个数与CPU的个数之间的关系，对程序执行速度有很大影响 10% - 15%。这其中或许存在一个最佳的关系。

#### 单线程读文件 

- 线程1读 sort1.txt，线程2读 sort2.txt。
- 当每次读取的数据量 buffer = 1MB 时达到最佳性能，此后增大buffer性能将不断下降。
- 相比于多协程读，单线程读文件的执行速度更能稳定在一个较小区间内。

#### 多协程读文件

- 线程1每次生成3个协程读 sort1.txt,线程2内每次生成9个协程读 sort2.txt。（经测试，3 + 9的组合下，执行速度最快）。
- 当 buffer >= 16MB 时，性能超过单线程读文件
- buffer大小无论在任何情况下都无法超过单线程读文件的最好情况（buffer = 1MB时的 0.58-0.59）。


| 每次读大小<br>(单位: B) | 多协程封装多线程     | 单线程无协程         |      |      |
| :---------------------- | :------------------- | :------------------- | :--- | :--- |
| 512k                    | 0.97-1.17            | 0.69<br>0.82<br>0.90 |      |      |
| 1024k(1m)               | 0.67<br>0.8<br>0.85  | 0.58-0.59            |      |      |
| 4096k(4m)               | 0.81<br>0.85<br>0.94 | 0.75-0.77            |      |      |
| 8m                      | 0.85-0.88            | 0.83-0.86            |      |      |
| 12m                     | 0.80<br>0.87<br>0.91 | 0.86-0.87            |      |      |
| 16m                     | 0.78<br>0.88<br>0.90 | 0.90-0.93            |      |      |
| 24m                     | 0.80<br>0.89<br>0.90 | 0.98-1.01            |      |      |
| 32m                     | 0.85<br>0.90<br>0.94 | 0.99-1.02            |      |      |
| 36m                     | 0.83<br>0.91<br>0.96 | 0.99-1.00            |      |      |
| 40m                     | 0.82<br>0.90<br>0.95 | 0.99-1.00            |      |      |
| 44m                     | 0.84<br>0.91<br>0.99 | 0.99-1.00            |      |      |
| 48m                     | 0.84<br>0.91<br>0.96 | 0.99-1.00            |      |      |



## 协程一定比线程快吗

否。

考虑这样一种情况，多线程环境下，分别将每个线程单独作为一个线程和协程。相比于线程版本，协程版本在进行切换时，需要多加入一个判断--下一个协程是否与当前协程位于同一线程中，即，是否引起线程切换。由于每个线程只有一个子线程或协程，切换时必然是线程切换，在这种情况下，协程将更慢。

考虑这样一种情况，多线程环境下，分别将每个线程单独作为一个线程和协程。相比于线程版本，协程版本在进行切换时，需要多加入一个判断--下一个协程是否与当前协程位于同一线程中，即，是否引起线程切换。由于每个线程只有一个子线程或协程，切换时必然是线程切换，在这种情况下，协程将更慢。
