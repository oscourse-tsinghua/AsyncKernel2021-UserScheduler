# 代码本身的理解

本例实现的是一个用户线程调度器，运行时就是把一些小的代码块创建为一个个的调度任务，并提供调度这些任务的函数，将这些任务执行完毕并退出。

使用对象描述此线程调度器，其成员变量包括调度对象Thread结构体（在asysc_std中称之为task），和当前正在调度的任务的索引，显然这两个变量在任何一个运行时中都必须存在。其次是成员方法，包括创建运行时实例new，初始化运行时init，启动运行时执行任务run，这三个函数也是必须的。

## 调度对象

1. id：唯一标识调度对象，并提供索引。
2. stack：调度任务需要执行的代码块，会包装为一个闭包，将函数名（地址）压入栈中。为了使运行时能够正确运行完所有任务后退出，还需要在每个任务的栈中压入一个函数，这个函数负责处理已执行完成的调度对象。
3. ctx：线程的执行环境，即任务切换时各个寄存器的值。
4. state：状态，包括Running，Ready，Wait（本例没有）。

显然以上4个变量是调度对象必备的，除了stack。在async_std中，任务需要执行的代码块存放于堆中。

## 本例中的不足之处：

1. 就像文章中所提到的，本例用yield_thread全局函数封装运行时库的t_thread函数，使得在任意时刻都可调用t_thread进行主动让出，当还未创建运行时实例时，将导致错误。
2. 运行时在创建时会分配最大调度任务数所需要的内存空间，有些程序任务数较少，造成了很大的内存浪费。并且，在遍历任务数组的调度算法下，调度效率会很低。

当然，此程序关键是提供了一种用户线程调度的框架，应着重理解这种结构。而对于程序的一些具体的实现，可以根据需要灵活更改。

# 

