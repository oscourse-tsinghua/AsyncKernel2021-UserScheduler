# 统一调度器需要解决的主要问题

每个进程都有一个主线程，当只有一个线程时，这个主线程就是进程本身，当这个线程发生调度，必然进行进程调度；不止一个线程时，多个线程共享进程同一地址空间的不同部分，发生调度时，可以进行线程调度，减少开销。

现在需要对线程-协程实现相似的功能。

当一个线程没有创建子协程时，这个线程本身就是一个协程，能够作为调度器的基本调度单位Task；当一个线程n有多个协程时，这个线程的主协程与子协程，能够作为不同的Task加入到调度器。

难点：

1. 数据结构的设计。线程控制块必须保留（包括线程栈和上下文），可以给每个线程额外创建一个用于调度器处理的Task，根据线程状态维护TCB与Task这两个数据结构的同步，比如线程结束时，先把Task移出调度器，再回收TCB。

![](https://github.com/oscourse-tsinghua/AsyncKernel2021-UserScheduler/blob/master/img_src/design_pic1.png)

2. 在线程的执行过程中，会在不同的时间点先后创建协程，需要使先后创建的协程可以动态加入调度器。目前同时执行多个future使用future::join函数，只能预先创建好需要执行的所有协程，然后调用join执行。

3. 线程与协程的执行方式
   
   协程创建的接口，会通过封装Async关键字实现，所以执行器执行一个协程，就是执行这个Future的poll函数。基于1、2，当线程没有子协程时，自身既是一个线程，也是一个主协程，会创建一个Task加入到调度器，此时调度器执行线程有两种选择：
   
   1. 一种是将线程所要执行的主函数封装为Async函数，那么调度器所调度运行的就是各个异步函数，根据Task结构体提供的标识，判断是否在同一线程、进程内切换，是否需要切换栈、地址空间。
      
      > 华科的飓风OS采取了类似的做法，调度器所调度执行的每一个Task都是Future的封装，但抛弃了传统线程的概念，只保留进程，起到地址空间隔断的作用。
   
   2. 另一种是延续传统的进程-线程设计，增加一个执行器内核线程。线程调用 task::new 接口创建并发送task到任务队列，执行器线程从任务队列中取得任务并执行。

# 数据结构

## 1. 进程

提供地址空间。

## 2. 线程

线程仅作为CPU执行环境的抽象，与协程灵活绑定，线程不再是函数栈或协程的上一层封装。

```rust
pub struct Thread{
    context: Context,
    stack: Option<Range<Address>>
}

impl Thread{
    pub fn new(f: fn()) -> Self {
        // 初始化线程属性值
        let mut thread = ...;

        thread
    }
}
```

## 3. 协程

调度器调度运行的基本对象。

```rust
pub struct Task{
    id: usize,
    thread: Option<>
    future: Future, // 任务的具体内容

    ...
}

impl Task{
    pub fn new(f: fn()) -> Self {
        let fut = async move{
            f();
        }
        // 初始化属性值
        let mut task = ...;
        // 插入调度队列
        todo()! 

        task
    }
}
```

## 4. 中断

协程的实际执行内容为Future，这意味着协程只能在特定位置让出（返回Pending），要使其能即时响应中断，必须保存上下文，**由此引出问题1：在哪保存上下文？**

> 关于Pending，就目前而言，使用 async 关键字创建的异步块或异步函数，并不会在中途返回Pending然后等待被唤醒，只有手动实现 poll 函数的Future，才可以在其中的指定位置返回Pending然后等待被waker唤醒，也就是说，即是是很长的异步任务，也会一直执行，直到任务完成。
> 
> 目前yield关键字没有具体作用，有可能在后续版本中，可以在 async {} 使用 yield 来指定返回 Pending 的位置。
> 
> 这带来的影响是，基于现在的Rust版本，协程在任意位置让出，也需要保存上下文。

在传统的线程调度器中，线程通过函数栈执行线程的主（子）函数或系统调用（内核栈）；在协程调度器中，协程的执行不需要栈，执行内容就是future本身，因此不需要用户栈，但是，陷入内核后执行内核任务（中断服务例程），需要把内核任务Pin在一个内存地址中，类似与使用内核栈执行系统调用。**由此引出问题2：如何构建这一块内存空间，问题3：如何把内核任务固定在该空间？**

答：这一块地址空间由进程分配，属于进程，需要中断的协程具有使用权。两种方式：1. 用时创建，用完回收；2. 创建一定数量的地址空间，不够再分配。（线程池）

# 调度器

调度器的作用是提供访问任务队列的接口，主要实现以下函数：

```rust
fn add_task(...);  // 向调度队列添加任务
fn pop_task(...);  // 从调度队列弹出下一个任务
fn peek_task(...); // 获取下一个任务的引用
fn set_task_state(...) // 设置任务状态
```

## 任务队列的数据结构

在向调度器添加任务时,为了维护调度队列中的task与线程控制块中的task的同步关系，应将 `Task` 创建为 `Arc<Task>`。

为了判断下一个任务与当前任务之间的切换是否在同一进程与同一线程中，TaskMetadata应当保存任务的pid与tid。

```rust
struct TaskMetadata {
    task: Arc<Task>,
    process_id: ProcessId,
    thread_id: ThreadId,
}

struct Scheduler {
    tasks: VecDeque<Arc<TaskMeta>>,
    current: Arc<TaskMeta>,
}
```

## 调度器如何添加任务

理想的程序执行过程：

```rust
// 线程主函数被封装为 Task 加入调度队列，此时调度队列中有1个Task。
// 当执行到协程创建函数时，将协程函数封装为第二个 Task 加入调度队列，
// 此时调度队列中有两个Task

fn main() {
   // 创建线程 
   thread::new(||{
        do_sth1;

        // 创建协程
        task::new(||{
            do_sth2;
        });

        do_sth3;
    }) ;
}
```

在调用 new 创建线程协程时，将任务插入队列。

线程中持有Task引用，Task中持有线程的引用，所以创建协程时，可以直接从一个全局指针处取得调度器和当前线程，调用各自提供的接口将Task插入。

创建线程时，先缺省 `Task列表`创建出KernelThread结构，然后创建Task，建立`Task -> 线程`的引用，再将Task插入线程和任务队列。即可解决第一次创建线程时，与Task的双向引用问题。

## 如何切换任务

线程和协程中，都持有上一层封装的引用，从调度队列中弹出下一任务时，比较pid与tid，执行进程切换 or 线程切换。

**!!!待细化**

# 执行器

在一个loop循环中，不断从任务队列中取出任务执行。

```rust
fn excutor() {
    1. 获取任务队列：参数 或 全局指针
    loop {
        2. 弹出下一个任务
        3. 如果任务为sleeping或idle，插入队列,进入下一轮循环
        4. 创建waker，封装为Context，执行任务，获取执行结果
        5. 如果任务未完成，插回队列；如果任务完成，将它从线程中删除
    }
}
```

## waker

任务的执行需要创建Context，目前cx仅有一个成员变量就是waker，所以执行任务的第一步是创建waker。

waker的作用是修改任务状态为执行器可以执行的状态（就绪态），本质上waker就是一个函数：`Arc<dyn Fn () + Send + Sync>`， 可以通过以下流程简单创建：

```rust
// 1. 任务唤醒函数的封装。即设置任务状态为可运行Ready
fn do_wake() {t: Arc<TaskMeta>} {
    set_task_state(t, 就绪);
}

// 2. 实现 ArcWake trait 的 wake_by_ref 函数
impl ArcWake for TaskMeta {
    fn wake_by_ref(arc_tm: &Arc<Self>) {
        unsafe {
            arc_tm.clone().do_wake();
        }
    } 
}

// 3. 使用。实现 ArcWake 之后，就可以调用 waker_ref 创建waker
let waker = waker_ref(&next_task);
let cx = &mut Context::from_waker(&*waker);
```

# 任务窃取

多核情况下，每个处理器运行一个执行器执行任务，如果访问同一个任务队列，必然导致竞争频繁发生。如果每个执行器单独拥有一个队列，当任务队列为空时，从其他任务队列中窃取任务。

```rust
线程与协程的关系：可以不是固定绑定的；可以灵活绑定，以节约的栈的资源；
线程可以视为CPU相关的资源属性；
仅在中断响应时，需要保存线程和当时在该线程环境中运行的协程的上下文；
线程的执行环境创建和执行协程绑定分成两步，把线程执行环境做成线程资源池；
```

# 参考资料

## [飓风OS](https://github.com/HUST-OS/tornado-os)

协作式调度、非实时系统。

### 用户态应用程序执行过程

将应用程序编译为二进制文件，并为其分配进程地址空间，加载到内存直接执行，不封装为Task，在应用程序中，可以使用共享调度器提供的接口，生成、执行task。

也就是说，应用程序不会被封装为task放到调度器中，也不在执行器的流程中执行，而是以二进制文件的方式直接在机器上运行。

这带来的问题时，当共享调度器中没有任务时，系统就会退出。**如果没有手动切换进入某进程的地址空间**，那么直到系统结束，该程序也不会被执行。

### 1.进程

传统的进程创建是从一个主函数开始，将这个函数加载为将要执行的主线程。但飓风OS取消了传统线程的概念，调度器处理的是来自各个地址空间的Task，进程的作用是隔断地址空间，保存Task。

进程这一概念更接近"地址空间映像"。

```rust
pub struct Process {
    /// 进程的编号
    id: ProcessId,
    /// 进程是否属于用户态进程
    is_user: bool,
    /// 地址空间
    inner: Mutex<ProcessInner>,
}

pub struct MemorySet {
    /// 本空间的页表和映射关系
    pub mapping: Mapping,
    /// 每个字段
    pub segments: Vec<Segment>,
    /// 所有分配的物理页面映射信息
    pub allocated_pairs: Vec<(VirtualPageNumber, FrameTracker)>,
    /// 这个映射关系的地址空间编号
    pub address_space_id: AddressSpaceId,
}
```

### 2.线程

硬件线程。

### 3.Task

调度器调度运行的实体，封装了一个future，即实际要执行的任务。

```rust
pub struct KernelTask {
    /// 任务的编号
    pub id: TaskId,
    /// 任务所属的进程
    pub process: Arc<Process>,
    /// 封装本任务运行的栈，初始为None,复用其他任务的栈
    pub inner: Mutex<TaskInner>,
    /// 任务的内容
    pub future: Mutex<Pin<Box<dyn Future<Output = ()> + 'static + Send + Sync>>>, // 用UnsafeCell代替Mutex会好一点
}

pub struct TaskInner {
    /// 本任务运行的栈，一段虚拟地址
    ///
    /// 内核任务复用执行器的栈。用户任务占有一个栈，下一个任务复用此栈。
    /// 强制中断暂停时，下一个任务使用新分配的栈。
    pub stack: Option<Range<VirtualAddress>>,
}
```

### 4.执行任务的方式

1. 创建任务
   
   ```rust
   let task1 = task::new_kernel{
       future, // 实际执行的任务
       进程,    // 任务所属的进程，以上二者会被打包为Task
       共享调度器, // ?????
       任务状态,
   }
   ```

2. 往调度器添加任务
   
   系统需要执行的future，实际经过了三层封装：
   
   future -> KernelTask(打包地址空间) -> KernelTaskRepr(打包调度器指针) ->
   
   TaskMeta(打包处理器编号)，最终将任务元数据插入到调度器的调度队列中。
   
   ```rust
   shared_payload.add_task(
                           硬件线程id,  // 处理器编号
                           地址空间id,
                           1.中创建的任务的指针
                          );
   
   pub struct TaskMeta {
       /// 运行此任务的硬件线程编号
       pub(crate) hart_id: usize,
       /// 地址空间的编号
       ///
       /// 内核地址空间编号是0，用户的地址空间编号从1开始增长
       pub(crate) address_space_id: AddressSpaceId,
       /// 元数据指针，由所在的地址空间解释
       task_repr: TaskRepr,
       /// 任务当前的状态
       pub(crate) state: TaskState,
   }
   ```

3. 执行任务
   
   如果是处于同一地址空间，可以直接执行任务的poll函数。否则，调用switch函数上下文，进入任务的地址空间。
   
   ```rust
   // 函数1: 调度器从任务队列弹出一个任务，根据是否属于当前地址空间，
   //       返回Task或下一个地址空间id
   // 函数2: 当任务返回Ready时调用，从任务队列中将其删除
   // 函数3: 将Task设置为指定状态
   async_rt::run_until_idle(函数1，函数2，函数3)
   ```

### 5.任务切换的方式

当下一个任务与当前任务不在同一地址空间（进程）时，调用switch函数切换地址空间与执行环境。

```rust
pub fn switch_to_user(
                      context: &SwapContext,
                      user_satp: usize, 
                      user_asid: usize
                     );
```

#### 切换到用户空间的过程：

1. 将应用程序编译为二进制文件（app.bin）。

2. 为进程分配地址空间，同时利用文件系统，将应用程序的二进制文件加载到该地址空间。
   
   ```rust
   async fn load_user(path: String) -> MemorySet {
       1. 获取新的地址空间编号
       2. 申请分配n个物理页面
       3. 将二进制文件放入刚申请的物理页面
       4. 将地址空间封装为MemorySet返回
   }
   ```

3. 在地址空间中，分配空闲物理页建立一些映射，创建上下文（页表基址satp，共享调度器地址gp，用户栈，寄存器值）。

以上三步封装在函数prepare中，注意到这个函数是一个async函数，会返回一个future，所以切换到用户空间的过程实际上是通过一个内核任务来完成的，所以使用的是内核的地址空间来执行此任务。当此任务完成，应用程序就成功加载到内存。

```rust
async fn prepare_user(path: String, kernel_stack_top: usize)
```

#### 上下文

```rust
pub struct SwapContext {
    // 用户栈起始地址保存于寄存器 sp，值存放于 x[1]
    pub x: [usize; 31], // 31个通用寄存器
    pub kernel_satp: usize, // 根页表始址，保存于RV的satp寄存器
    pub kernel_stack: usize, // 内核栈指针
    pub user_trap_handler: usize, // 陷入内核时的处理函数
    pub epc: usize, // sepc 寄存器
    pub kernel_tp: usize, // 内核 tp 寄存器的值
                          // tp: thread pointer
}
```

每个用户程序在切换时，将上下文保存在属于自己的一个页中，这个片内存区域称之为`.swap段`，地址空间最高地址开始的第二页为其起始地址，称之为`SWAP_FRAME_VA`，是一个常量，用户程序通过 SWAP_FRAME_VA - 4KB*用户地址空间编号得到所属页的起始地址。 

![](/Users/wangwenzhi/Desktop/截图/截屏2021-09-12%20下午12.39.37.png)

### 6.如何响应中断

## Linux内核

Linux内核中，将进程与线程不加区分的表示为 `struct task_struct`，线程仅仅被视为与某进程共享一些资源（主要是地址空间）的进程，是否共享地址空间，几乎是Linux中进程和线程间的唯一区别。

### 内核栈与用户栈

用户栈用于执行线程的任务函数，在用户态中，CPU的esp寄存器保存的是用户栈栈顶指针。

内核栈用于陷入内核，执行内核函数时使用。刚陷入内核和即将从内核返回时，内核栈为空。陷入内核时，要将用户栈栈顶指针压入内核栈，用于返回。

用户栈和内核栈就是不同特权级（用户态和内核态）下，线程执行函数的函数栈。

> 为什么不只用一个栈？
> 
>     系统调用等内核程序必须在内核态下执行，所以必须有内核栈。如果只保留内核栈，在内核栈的执行线程的任务函数，用户程序的不可预测性将带来极大的安全隐患。

## 执行器线程

[从头实现Rust异步执行器 :: steven的个人博客](https://stevenbai.top/rust/build_your_own_executor/)
