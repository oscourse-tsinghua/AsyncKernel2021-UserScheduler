# 统一调度器需要解决的主要问题

每个进程都有一个主线程，当只有一个线程时，这个主线程就是进程本身，当这个线程发生调度，必然进行进程调度；不止一个线程时，多个线程共享进程同一地址空间的不同部分，发生调度时，可以进行线程调度，减少开销。

现在需要对线程-协程实现相似的功能。

当一个线程没有创建子协程时，这个线程本身就是一个协程，能够作为调度器的基本调度单位Task；当一个线程有多个协程时，这个线程的主协程与子协程，能够作为不同的Task加入到调度器。

难点：

1. 数据结构的设计。线程控制块必须保留（包括线程栈和上下文），可以给每个线程额外创建一个用于调度器处理的Task，根据线程状态维护TCB与Task这两个数据结构的同步，比如线程结束时，先把Task移出调度器，再回收TCB。

![](https://github.com/oscourse-tsinghua/AsyncKernel2021-UserScheduler/blob/master/img_src/design_pic1.png)

2. 在线程的执行过程中，会在不同的时间点先后创建协程，需要使先后创建的协程可以动态加入调度器。目前同时执行多个future使用future::join函数，只能预先创建好需要执行的所有协程，然后调用join执行。

3. 调度器如何执行线程与协程。
   
   协程创建的接口，会通过封装Async关键字实现，所以调度器执行一个协程，就是执行这个Future的poll函数。基于1、2，当线程没有子协程时，自身既是一个线程，也是一个主协程，会创建一个Task加入到调度器，此时调度器执行线程有两种选择：
   
   1. 一种是将线程所要执行的主函数封装为Async函数，那么调度器所调度运行的就是各个异步函数，根据Task结构体提供的标识，判断是否在同一线程、进程内切换，是否需要切换栈、地址空间。
      
      > 华科的飓风OS采取了类似的做法，调度器所调度执行的每一个Task都是Future的封装，但抛弃了传统线程的概念，只保留进程，起到地址空间隔断的作用。
   
   2. 另一种是将线程的主函数作为普通函数，那么Task将封装两种调度对象：线程和future，根据标识信息，进入不同的执行流程。





# 数据结构

## 1. 进程

提供地址空间。



## 2. 线程

调用 thread::spawn 创建线程，传入一个函数，接口内部调用协程创建接口 coroutine::spawn 将这个函数封装为协程，作为线程的主协程。每个线程都有一个主协程。

```rust
pub struct Thread{
    id: usize,
    process: Arc<Process>, // 进程指针
    tasks: Vec<Task>,

    ...
}

impl Thread{
    pub fn spawn(f: fn()) -> Self {
        // 初始化线程属性值
        let mut thread = ...;
        
        // 创建协程
        let task = Task::spawn(f);
        thread.add_task(task);

        thread
    }
}
```



## 3. 协程

调度器调度运行的基本对象。

```rust
pub struct Task{
    id: usize,
    thread: Arc<Thread>, // 线程指针
    future: Future, // 任务的具体内容
    
    ...
}

impl Task{
    pub fn new(f: fn()) -> Self {
        let fut = async move{
            f();
        }
        // 初始化属性值
        let mut task = ...;
        
        task
    }
}
```





# 调度器

## 1.数据结构

调度器访问线程 or 协程 ？





# 参考资料

## [飓风OS](https://github.com/HUST-OS/tornado-os)

协作式调度、非实时系统。

### 用户态应用程序执行过程

将应用程序编译为二进制文件，并为其分配进程地址空间，加载到内存直接执行，不封装为Task，在应用程序中，可以使用共享调度器提供的接口，生成、执行task。

也就是说，应用程序不会被封装为task放到调度器中，也不在执行器的流程中执行，而是以二进制文件的方式直接在机器上运行。

这带来的问题时，当共享调度器中没有任务时，系统就会退出。**如果没有手动切换进入某进程的地址空间**，那么直到系统结束，该程序也不会被执行。



### 1.进程

传统的进程创建是从一个主函数开始，将这个函数加载为将要执行的主线程。但飓风OS取消了传统线程的概念，调度器处理的是来自各个地址空间的Task，进程的作用是隔断地址空间，保存Task。

进程这一概念更接近"地址空间映像"。

```rust
pub struct Process {
    /// 进程的编号
    id: ProcessId,
    /// 进程是否属于用户态进程
    is_user: bool,
    /// 地址空间
    inner: Mutex<ProcessInner>,
}

pub struct MemorySet {
    /// 本空间的页表和映射关系
    pub mapping: Mapping,
    /// 每个字段
    pub segments: Vec<Segment>,
    /// 所有分配的物理页面映射信息
    pub allocated_pairs: Vec<(VirtualPageNumber, FrameTracker)>,
    /// 这个映射关系的地址空间编号
    pub address_space_id: AddressSpaceId,
}
```



### 2.线程

硬件线程。



### 3.Task

调度器调度运行的实体，封装了一个future，即实际要执行的任务。

```rust
pub struct KernelTask {
    /// 任务的编号
    pub id: TaskId,
    /// 任务所属的进程
    pub process: Arc<Process>,
    /// 封装本任务运行的栈，初始为None,复用其他任务的栈
    pub inner: Mutex<TaskInner>,
    /// 任务的内容
    pub future: Mutex<Pin<Box<dyn Future<Output = ()> + 'static + Send + Sync>>>, // 用UnsafeCell代替Mutex会好一点
}

pub struct TaskInner {
    /// 本任务运行的栈，一段虚拟地址
    ///
    /// 内核任务复用执行器的栈。用户任务占有一个栈，下一个任务复用此栈。
    /// 强制中断暂停时，下一个任务使用新分配的栈。
    pub stack: Option<Range<VirtualAddress>>,
}
```



### 4.执行任务的方式

1. 创建任务
   
   ```rust
   let task1 = task::new_kernel{
       future, // 实际执行的任务
       进程,    // 任务所属的进程，以上二者会被打包为Task
       共享调度器, // ?????
       任务状态,
   }
   ```

2. 往调度器添加任务
   
   系统需要执行的future，实际经过了三层封装：
   
   future -> KernelTask(打包地址空间) -> KernelTaskRepr(打包调度器指针) ->
   
   TaskMeta(打包处理器编号)，最终将任务元数据插入到调度器的调度队列中。
   
   ```rust
   shared_payload.add_task(
                           硬件线程id,  // 处理器编号
                           地址空间id,
                           1.中创建的任务的指针
                          );
   
   pub struct TaskMeta {
       /// 运行此任务的硬件线程编号
       pub(crate) hart_id: usize,
       /// 地址空间的编号
       ///
       /// 内核地址空间编号是0，用户的地址空间编号从1开始增长
       pub(crate) address_space_id: AddressSpaceId,
       /// 元数据指针，由所在的地址空间解释
       task_repr: TaskRepr,
       /// 任务当前的状态
       pub(crate) state: TaskState,
   }
   ```

3. 执行任务
   
   如果是处于同一地址空间，可以直接执行任务的poll函数。否则，调用switch函数上下文，进入任务的地址空间。
   
   ```rust
   // 函数1: 调度器从任务队列弹出一个任务，根据是否属于当前地址空间，
   //       返回Task或下一个地址空间id
   // 函数2: 当任务返回Ready时调用，从任务队列中将其删除
   // 函数3: 将Task设置为指定状态
   async_rt::run_until_idle(函数1，函数2，函数3)
   ```



### 5.任务切换的方式

当下一个任务与当前任务不在同一地址空间（进程）时，调用switch函数切换地址空间与执行环境。

```rust
pub fn switch_to_user(
                      context: &SwapContext,
                      user_satp: usize, 
                      user_asid: usize
                     );
```

#### 切换到用户空间的过程：

1. 将应用程序编译为二进制文件（app.bin）。

2. 为进程分配地址空间，同时利用文件系统，将应用程序的二进制文件加载到该地址空间。
   
   ```rust
   async fn load_user(path: String) -> MemorySet {
       1. 获取新的地址空间编号
       2. 申请分配n个物理页面
       3. 将二进制文件放入刚申请的物理页面
       4. 将地址空间封装为MemorySet返回
   }
   ```

3. 在地址空间中，分配空闲物理页建立一些映射，包括上下文、栈，寄存器值（页表基址satp，共享调度器地址gp）。

以上三步封装在函数prepare中，注意到这个函数是一个async函数，会返回一个future，所以切换到用户空间的过程实际上是通过一个内核任务来完成的，所以使用的是内核的地址空间来执行此任务。当此任务完成，应用程序就成功加载到内存。

```rust
async fn prepare_user(path: String, kernel_stack_top: usize)
```



### 6.如何响应中断
