# 统一调度器需要解决的主要问题

每个进程都有一个主线程，当只有一个线程时，这个主线程就是进程本身，当这个线程发生调度，必然进行进程调度；不止一个线程时，多个线程共享进程同一地址空间的不同部分，发生调度时，可以进行线程调度，减少开销。

现在需要对线程-协程实现相似的功能。

当一个线程没有创建子协程时，这个线程本身就是一个协程，能够作为调度器的基本调度单位Task；当一个线程n有多个协程时，这个线程的主协程与子协程，能够作为不同的Task加入到调度器。

难点：

1. 数据结构的设计。线程控制块必须保留（包括线程栈和上下文），可以给每个线程额外创建一个用于调度器处理的Task，根据线程状态维护TCB与Task这两个数据结构的同步，比如线程结束时，先把Task移出调度器，再回收TCB。

![](https://github.com/oscourse-tsinghua/AsyncKernel2021-UserScheduler/blob/master/img_src/design_pic1.png)

2. 在线程的执行过程中，会在不同的时间点先后创建协程，需要使先后创建的协程可以动态加入调度器。目前同时执行多个future使用future::join函数，只能预先创建好需要执行的所有协程，然后调用join执行。

3. 线程与协程的执行方式
   
   协程创建的接口，会通过封装Async关键字实现，所以执行器执行一个协程，就是执行这个Future的poll函数。基于1、2，当线程没有子协程时，自身既是一个线程，也是一个主协程，会创建一个Task加入到调度器，此时调度器执行线程有两种选择：
   
   1. 一种是将线程所要执行的主函数封装为Async函数，那么调度器所调度运行的就是各个异步函数，根据Task结构体提供的标识，判断是否在同一线程、进程内切换，是否需要切换栈、地址空间。
      
      > 华科的飓风OS采取了类似的做法，调度器所调度执行的每一个Task都是Future的封装，但抛弃了传统线程的概念，只保留进程，起到地址空间隔断的作用。
   
   2. 另一种是延续传统的进程-线程设计，增加一个执行器内核线程。线程调用 task::new 接口创建并发送task到任务队列，执行器线程从任务队列中取得任务并执行。

# 数据结构

## 1. 进程

提供地址空间。

## 2. 线程

调用 thread::new 创建线程，传入一个函数，接口内部调用协程创建接口 task::new 将这个函数封装为协程，作为线程的主协程。每个线程都有一个主协程。

```rust
pub struct Thread{
    id: usize,
    process: Arc<Process>, // 进程指针
    tasks: Vec<Task>,

    ...
}

impl Thread{
    pub fn new(f: fn()) -> Self {
        // 初始化线程属性值
        let mut thread = ...;

        // 创建协程
        let task = Task::get_task(f,Arc::new(thread));
        // 插入调度器，插入线程
        thread.add_task(task);

        thread
    }
}
```

## 3. 协程

调度器调度运行的基本对象。

> 关键问题：在创建协程时，如何将协程插入到父线程的task列表中？
> 
> 创建协程有两种情况：
> 
>     1.thread::new 创建新线程时创建主协程。
> 
>     2.task::new 在当前线程内创建新协程：直接从调度器获取当前线程，然后插入。
> 
>     针对情况1，可以提供另一个接口 task::get_task ，该接口只负责创建协程，不负责插入调度队列、插入线程task列表。这两个过程在 thread::new 中手动执行。

```rust
pub struct Task{
    id: usize,
    thread: Arc<Thread>, // 线程指针
    future: Future, // 任务的具体内容

    ...
}

impl Task{
    pub fn new(f: fn()) -> Self {
        let fut = async move{
            f();
        }
        // 初始化属性值
        let mut task = ...;
        // 插入调度队列，插入线程

        task
    }
}
```

# 调度器

调度器的作用是提供访问任务队列的接口，主要实现以下函数：

```rust
fn add_task(...);  // 向调度队列添加任务
fn pop_task(...);  // 从调度队列弹出下一个任务
fn peek_task(...); // 获取下一个任务的引用
fn set_task_state(...) // 设置任务状态
```

## 任务队列的数据结构

在向调度器添加任务时,为了维护调度队列中的task与线程控制块中的task的同步关系，应将 `Task` 创建为 `Arc<Task>`。

为了判断下一个任务与当前任务之间的切换是否在同一进程与同一线程中，TaskMetadata应当保存任务的pid与tid。

```rust
struct TaskMetadata {
    task: Arc<Task>,
    process_id: ProcessId,
    thread_id: ThreadId,
}

struct Scheduler {
    tasks: VecDeque<Arc<TaskMeta>>,
    current: Arc<TaskMeta>,
}
```

## 调度器如何添加任务

理想的程序执行过程：

```rust
// 线程主函数被封装为 Task 加入调度队列，此时调度队列中有1个Task。
// 当执行到协程创建函数时，将协程函数封装为第二个 Task 加入调度队列，
// 此时调度队列中有两个Task

fn main() {
   // 创建线程 
   thread::new(||{
        do_sth1;

        // 创建协程
        task::new(||{
            do_sth2;
        });

        do_sth3;
    }) ;
}
```

在调用 new 创建线程协程时，将任务插入队列。

线程中持有Task引用，Task中持有线程的引用，所以创建协程时，可以直接从一个全局指针处取得调度器和当前线程，调用各自提供的接口将Task插入。

创建线程时，先缺省 `Task列表`创建出KernelThread结构，然后创建Task，建立`Task -> 线程`的引用，再将Task插入线程和任务队列。即可解决第一次创建线程时，与Task的双向引用问题。

## 如何切换任务

线程和协程中，都持有上一层封装的引用，从调度队列中弹出下一任务时，比较pid与tid，执行进程切换 or 线程切换。

**!!!待细化**

# 执行器

在一个loop循环中，不断从任务队列中取出任务执行。

```rust
fn excutor() {
    1. 获取任务队列：参数 或 全局指针
    loop {
        2. 弹出下一个任务
        3. 如果任务为sleeping或idle，插入队列,进入下一轮循环
        4. 创建waker，封装为Context，执行任务，获取执行结果
        5. 如果任务未完成，插回队列；如果任务完成，将它从线程中删除
    }
}
```

## waker

任务的执行需要创建Context，目前cx仅有一个成员变量就是waker，所以执行任务的第一步是创建waker。

waker的作用是修改任务状态为执行器可以执行的状态（就绪态），本质上waker就是一个函数：`Arc<dyn Fn () + Send + Sync>`， 可以通过以下流程简单创建：

```rust
// 1. 任务唤醒函数的封装。即设置任务状态为可运行Ready
fn do_wake() {t: Arc<TaskMeta>} {
    set_task_state(t, 就绪);
}

// 2. 实现 ArcWake trait 的 wake_by_ref 函数
impl ArcWake for TaskMeta {
    fn wake_by_ref(arc_tm: &Arc<Self>) {
        unsafe {
            arc_tm.clone().do_wake();
        }
    } 
}

// 3. 使用。实现 ArcWake 之后，就可以调用 waker_ref 创建waker
let waker = waker_ref(&next_task);
let cx = &mut Context::from_waker(&*waker);
```

# 任务窃取

多核情况下，每个处理器运行一个执行器执行任务，如果访问同一个任务队列，必然导致竞争频繁发生。如果每个执行器单独拥有一个队列，当任务队列为空时，从其他任务队列中窃取任务。



# 参考资料

## [飓风OS](https://github.com/HUST-OS/tornado-os)

协作式调度、非实时系统。

### 用户态应用程序执行过程

将应用程序编译为二进制文件，并为其分配进程地址空间，加载到内存直接执行，不封装为Task，在应用程序中，可以使用共享调度器提供的接口，生成、执行task。

也就是说，应用程序不会被封装为task放到调度器中，也不在执行器的流程中执行，而是以二进制文件的方式直接在机器上运行。

这带来的问题时，当共享调度器中没有任务时，系统就会退出。**如果没有手动切换进入某进程的地址空间**，那么直到系统结束，该程序也不会被执行。

### 1.进程

传统的进程创建是从一个主函数开始，将这个函数加载为将要执行的主线程。但飓风OS取消了传统线程的概念，调度器处理的是来自各个地址空间的Task，进程的作用是隔断地址空间，保存Task。

进程这一概念更接近"地址空间映像"。

```rust
pub struct Process {
    /// 进程的编号
    id: ProcessId,
    /// 进程是否属于用户态进程
    is_user: bool,
    /// 地址空间
    inner: Mutex<ProcessInner>,
}

pub struct MemorySet {
    /// 本空间的页表和映射关系
    pub mapping: Mapping,
    /// 每个字段
    pub segments: Vec<Segment>,
    /// 所有分配的物理页面映射信息
    pub allocated_pairs: Vec<(VirtualPageNumber, FrameTracker)>,
    /// 这个映射关系的地址空间编号
    pub address_space_id: AddressSpaceId,
}
```

### 2.线程

硬件线程。

### 3.Task

调度器调度运行的实体，封装了一个future，即实际要执行的任务。

```rust
pub struct KernelTask {
    /// 任务的编号
    pub id: TaskId,
    /// 任务所属的进程
    pub process: Arc<Process>,
    /// 封装本任务运行的栈，初始为None,复用其他任务的栈
    pub inner: Mutex<TaskInner>,
    /// 任务的内容
    pub future: Mutex<Pin<Box<dyn Future<Output = ()> + 'static + Send + Sync>>>, // 用UnsafeCell代替Mutex会好一点
}

pub struct TaskInner {
    /// 本任务运行的栈，一段虚拟地址
    ///
    /// 内核任务复用执行器的栈。用户任务占有一个栈，下一个任务复用此栈。
    /// 强制中断暂停时，下一个任务使用新分配的栈。
    pub stack: Option<Range<VirtualAddress>>,
}
```

### 4.执行任务的方式

1. 创建任务
   
   ```rust
   let task1 = task::new_kernel{
       future, // 实际执行的任务
       进程,    // 任务所属的进程，以上二者会被打包为Task
       共享调度器, // ?????
       任务状态,
   }
   ```

2. 往调度器添加任务
   
   系统需要执行的future，实际经过了三层封装：
   
   future -> KernelTask(打包地址空间) -> KernelTaskRepr(打包调度器指针) ->
   
   TaskMeta(打包处理器编号)，最终将任务元数据插入到调度器的调度队列中。
   
   ```rust
   shared_payload.add_task(
                           硬件线程id,  // 处理器编号
                           地址空间id,
                           1.中创建的任务的指针
                          );
   
   pub struct TaskMeta {
       /// 运行此任务的硬件线程编号
       pub(crate) hart_id: usize,
       /// 地址空间的编号
       ///
       /// 内核地址空间编号是0，用户的地址空间编号从1开始增长
       pub(crate) address_space_id: AddressSpaceId,
       /// 元数据指针，由所在的地址空间解释
       task_repr: TaskRepr,
       /// 任务当前的状态
       pub(crate) state: TaskState,
   }
   ```

3. 执行任务
   
   如果是处于同一地址空间，可以直接执行任务的poll函数。否则，调用switch函数上下文，进入任务的地址空间。
   
   ```rust
   // 函数1: 调度器从任务队列弹出一个任务，根据是否属于当前地址空间，
   //       返回Task或下一个地址空间id
   // 函数2: 当任务返回Ready时调用，从任务队列中将其删除
   // 函数3: 将Task设置为指定状态
   async_rt::run_until_idle(函数1，函数2，函数3)
   ```

### 5.任务切换的方式

当下一个任务与当前任务不在同一地址空间（进程）时，调用switch函数切换地址空间与执行环境。

```rust
pub fn switch_to_user(
                      context: &SwapContext,
                      user_satp: usize, 
                      user_asid: usize
                     );
```

#### 切换到用户空间的过程：

1. 将应用程序编译为二进制文件（app.bin）。

2. 为进程分配地址空间，同时利用文件系统，将应用程序的二进制文件加载到该地址空间。
   
   ```rust
   async fn load_user(path: String) -> MemorySet {
       1. 获取新的地址空间编号
       2. 申请分配n个物理页面
       3. 将二进制文件放入刚申请的物理页面
       4. 将地址空间封装为MemorySet返回
   }
   ```

3. 在地址空间中，分配空闲物理页建立一些映射，包括上下文、栈，寄存器值（页表基址satp，共享调度器地址gp）。

以上三步封装在函数prepare中，注意到这个函数是一个async函数，会返回一个future，所以切换到用户空间的过程实际上是通过一个内核任务来完成的，所以使用的是内核的地址空间来执行此任务。当此任务完成，应用程序就成功加载到内存。

```rust
async fn prepare_user(path: String, kernel_stack_top: usize)
```

### 6.如何响应中断

## 执行器线程

[从头实现Rust异步执行器 :: steven的个人博客](https://stevenbai.top/rust/build_your_own_executor/)
