# 统一调度器需要解决的主要问题

每个进程都有一个主线程，当只有一个线程时，这个主线程就是进程本身，当这个线程发生调度，必然进行进程调度；不止一个线程时，多个线程共享进程同一地址空间的不同部分，发生调度时，可以进行线程调度，减少开销。

现在需要对线程-协程实现相似的功能。

当一个线程没有创建子协程时，这个线程本身就是一个协程，能够作为调度器的基本调度单位Task；当一个线程n有多个协程时，这个线程的主协程与子协程，能够作为不同的Task加入到调度器。

难点：

1. 数据结构的设计。线程控制块必须保留（包括线程栈和上下文），可以给每个线程额外创建一个用于调度器处理的Task，根据线程状态维护TCB与Task这两个数据结构的同步，比如线程结束时，先把Task移出调度器，再回收TCB。

![](https://github.com/oscourse-tsinghua/AsyncKernel2021-UserScheduler/blob/master/img_src/design_pic1.png)

2. 在线程的执行过程中，会在不同的时间点先后创建协程，需要使先后创建的协程可以动态加入调度器。目前同时执行多个future使用future::join函数，只能预先创建好需要执行的所有协程，然后调用join执行。

3. 线程与协程的执行方式
   
   协程创建的接口，会通过封装Async关键字实现，所以执行器执行一个协程，就是执行这个Future的poll函数。基于1、2，当线程没有子协程时，自身既是一个线程，也是一个主协程，会创建一个Task加入到调度器，此时调度器执行线程有两种选择：
   
   1. 一种是将线程所要执行的主函数封装为Async函数，那么调度器所调度运行的就是各个异步函数，根据Task结构体提供的标识，判断是否在同一线程、进程内切换，是否需要切换栈、地址空间。
      
      > 华科的飓风OS采取了类似的做法，调度器所调度执行的每一个Task都是Future的封装，但抛弃了传统线程的概念，只保留进程，起到地址空间隔断的作用。
   
   2. 另一种是延续传统的进程-线程设计，增加一个执行器内核线程。线程调用 task::new 接口创建并发送task到任务队列，执行器线程从任务队列中取得任务并执行。

# 数据结构

## 1. 进程

提供地址空间。

## 2. 线程

线程仅作为CPU的抽象，与协程灵活绑定，每个CPU有且仅有一个线程，封装CPU的执行环境，内核栈地址，内核页表，用户栈等，每个换上CPU执行的任务都使用这个线程的用户栈，当任务被强制中断时，用户栈被该任务拿走，为其分配一个新的用户栈，并且要将这个页面共享给所有进程。

也就是说，线程不一定只属于某个进程，仅作为CPU执行环境的记录，提供给执行单位（协程）。

risc-v有一个`tp`寄存器用于保存当前正在执行的线程指针，可以在内核空间固定位置分配一个页来记录每个CPU的线程，比如：分配一页4KB，每个线程结构体占据1KB，位于内存中的固定位置。

```rust
pub struct Thread{
    pub context: Context,
    pub pid: usize，
    ...
}

impl Thread{
    pub fn new(f: fn()) -> Self {
        // 初始化线程属性值
        let mut thread = ...;

        thread
    }
}
```

## 3. 协程

调度器处理的最小单位，future的上一层封装。上下文初始为`None`，因为不一定会用到，当协程被强制中断时，从当前运行的CPU的（硬件）线程中取出上下文，复制一份给协程，然后修改线程的栈顶指针为新的空闲栈。

但是这有一个问题：协程的上下文，从无到有，也就是绑定这个动作在哪完成？

考虑两类情况：

1. 单核情况，以及多核但是所有核都处于用户态情况：中断在协程的核上处理并返回，不需要修改协程控制块的上下文；

2. 多核且至少有一个CPU处于内核态：中断**转发**（ 硬件完成）至内核运行的CPU，中断的协程需要保存上下文到协程控制块，然后切换下一个协程运行，如果下一个线程有上下文，那么可以换上；如果没有，可以由所在进程申请分配两个页，保存上下文和堆栈（对应每个进程使用一个堆栈），或是从内核的空闲页中获取（对应所有进程共用一个堆栈）。

保存上下文的方案：

放到调度器中来做。

调度器设置一个当前正在执行的协程的指针，以某种方式得知前一个协程栈并不空（使用一个标志位，执行器执行前置为1，正常执行退出置为0），将上下文保存至该协程控制块，然后切换下一个协程，如果下一个协程的上下文有内容，则直接加载，恢复运行；如果没有，则由当前进程提供新的堆栈。

```rust
pub struct TaskInner {
    pub context: Option<Context>

    //pub context: Option<usize>

    ...
}


pub struct Task{
    id: usize,
    // 任务上下文
    inner: TaskInner,
    // 任务的具体内容 
    future: Future,

    ...
} 


impl Task{
    pub fn new(f: fn()) -> Self {
        let fut = async move{
            f();
        }
         // 初始化属性值
         let mut task = ...;
         // 插入调度队列
         todo()! 

         task
     }
}
```

## 4. 中断

### 协程响应中断的过程

1. 一个CPU：内核无任务，用户进程占据CPU，中断到来，陷入内核，保存用户进程上下文于内核，处理中断，返回，修改context。

2. 多核：
   
   1. 内核没有在CPU上运行，与单核相同。
   
   2. 内核在其他CPU上运行，1.可以类似于单核处理；2.将中断发送给内核CPU处理，协程占据的这个CPU将等待中断返回，此时将下一个任务换上CPU。

```rust
ecall => 保存上下文.S => jr指令 => 内核trap_handler

fn trap_handler(...) {
    1. 从硬件线程的上下文中获取中断参数；
    2. 如果其他CPU上没有内核正在运行，那就正常进入中断处理流程；
    3. 如果其他CPU上处于内核态运行，就把中断转发，然后进入调度流程；
}
```

### 上下文

上下文是系统中的运行实体（协程）的属性，只有在非让出点让出时才会用到，而且协程是更轻量级的任务实体，所以，没有必要为每个协程预先分配一个上下文结构。当协程响应中断时，保存当前CPU执行环境于上下文，

```rust
pub struct Context {
    // cpu 所有寄存器的值
    pub registers: [usize;寄存器数], 
    // 一级页表起始地址，rv中保存于satp寄存器
    pub satp: usize, 

    // 内核栈地址，用户态陷入内核态时设置sp寄存器
    pub kernel_stack_address: usize, 
    // 内核页表
    pub kernel_satp: usize,

    // 用户栈
    pub user_stack_address: usize,

    // 内核中断处理程序入口地址
    pub kernel_trap_handler: usize
    ...
}
```

# 调度器

调度器的作用是提供访问任务队列的接口，主要实现以下函数：

```rust
fn add_task(...);  // 向调度队列添加任务
fn pop_task(...);  // 从调度队列弹出下一个任务
fn peek_task(...); // 获取下一个任务的引用
fn set_task_state(...) // 设置任务状态
```

## 任务队列的数据结构

在向调度器添加任务时,为了维护调度队列中的task与线程控制块中的task的同步关系，应将 `Task` 创建为 `Arc<Task>`。

为了判断下一个任务与当前任务之间的切换是否在同一进程与同一线程中，TaskMetadata应当保存任务的pid与tid。

```rust
struct TaskMetadata {
    task: Arc<Task>,
    process_id: ProcessId,
    thread_id: ThreadId,
}

struct Scheduler {
    tasks: VecDeque<Arc<TaskMeta>>,
    current: Arc<TaskMeta>,
}
```

## 调度器如何添加任务

理想的程序执行过程：

```rust
// 线程主函数被封装为 Task 加入调度队列，此时调度队列中有1个Task。
// 当执行到协程创建函数时，将协程函数封装为第二个 Task 加入调度队列，
// 此时调度队列中有两个Task

fn main() {
   // 创建线程 
   thread::new(||{
        do_sth1;

        // 创建协程
        task::new(||{
            do_sth2;
        });

        do_sth3;
    }) ;
}
```

在调用 new 创建线程协程时，将任务插入队列。

线程中持有Task引用，Task中持有线程的引用，所以创建协程时，可以直接从一个全局指针处取得调度器和当前线程，调用各自提供的接口将Task插入。

创建线程时，先缺省 `Task列表`创建出KernelThread结构，然后创建Task，建立`Task -> 线程`的引用，再将Task插入线程和任务队列。即可解决第一次创建线程时，与Task的双向引用问题。

## 如何切换任务

下一个协程没有携带上下文时，执行器直接执行协程的future的poll；

下一个协程携带上下文时，需要加载上下文到CPU（switch.S），类似于传统线程的切换方式；

# 执行器

在一个loop循环中，不断从任务队列中取出任务执行。

```rust
fn excutor() {
    1. 获取任务队列：参数 或 全局指针
    loop {
        2. 判断是否需要保存前一个协程的上下文；
        3. 弹出下一个任务；
        4. 如果任务为sleeping或idle，插入队列,进入下一轮循环；
        5. 切换到协程的地址空间；
        6. 判断下一个协程是否包含上下文，如果不包含，直接执行；如果包含，进行类似chanting线程切换；
        7. 如果任务未完成，插回队列；如果任务完成，将它从线程中删除
    }
}
```

## waker

任务的执行需要创建Context，目前cx仅有一个成员变量就是waker，所以执行任务的第一步是创建waker。

waker的作用是修改任务状态为执行器可以执行的状态（就绪态），本质上waker就是一个函数：`Arc<dyn Fn () + Send + Sync>`， 可以通过以下流程简单创建：

```rust
// 1. 任务唤醒函数的封装。即设置任务状态为可运行Ready
fn do_wake() {t: Arc<TaskMeta>} {
    set_task_state(t, 就绪);
}

// 2. 实现 ArcWake trait 的 wake_by_ref 函数
impl ArcWake for TaskMeta {
    fn wake_by_ref(arc_tm: &Arc<Self>) {
        unsafe {
            arc_tm.clone().do_wake();
        }
    } 
}

// 3. 使用。实现 ArcWake 之后，就可以调用 waker_ref 创建waker
let waker = waker_ref(&next_task);
let cx = &mut Context::from_waker(&*waker);
```

## 堆栈

属于程序的执行环境的功能支持。程序经过编译后，根据实际生成的指令，会对栈进行插入和删除操作。

每个正在运行的执行单位（传统线程或协程）都有自己的栈，用于支持函数的调用/返回机制。

栈帧（stack frame）：调用一个函数，会生成一个栈帧压入栈顶，栈帧包括**返回地址、参数、局部变量**。函数返回时，栈帧出栈。

### 分配策略

- 内核栈：为每个CPU分配一个内核栈；

- 用户栈：为每个CPU分配一个用户栈，当前一个任务执行完毕，或是在让出点主动让出，此时的栈以及上下文可以不保存（由于协程状态机的实现方式）；当一个正在执行的任务被强制中断时，需要保存任务的上下文，封装进协程（之前Context是None），Context生成之后，分配一个新的用户栈给当前CPU。

> 任务执行完毕或主动让出，不需要保存上下文的原因：
> 
> 显然，执行完毕时栈为空，没东西需要保存，且任务也马上会被删除。
> 
> 主动让出时，本质上是一个主函数（poll）执行完毕，返回了一个值（Pending），这个时候栈也是空的，没有东西需要保存。

响应中断的协程会拿走所在CPU的栈，此时该进程需要申请分配一个新的页，并把这个页共享给所有进程。**这里如何实现？**

答：内核初始化时，分配一定数量的页作为储备用户栈，从中选择CPU数个页作为各个CPU运行用户进程的用户栈，并在进程初始化时，在其页表中写入这些栈的映射。当某个进程的某个协程被中断时，将当前CPU的执行环境（包括此时的栈顶指针）封装进协程，然后从空闲的栈中选一个作为该CPU的新栈。

被中断的协程恢复时，将空栈重新标记为空闲，然后加载被中断协程的栈。

### 封装方式

```rust

```

### 内核栈的设计

协程的实际执行内容为Future，这意味着协程只能在特定位置让出（返回Pending），要使其能即时响应中断，必须保存上下文，**由此引出问题1：那么在哪保存内核栈？**

答：

两种方式：

1. tonador的预先分配，内核空间中固定的一段空间，在每个进程创建时，为每个进程分配一页，作为内核栈。（多核情况下，分配CPU数个内核栈或许更好，但这带来的问题是）

2. 内核分配一定数量的页作为内核栈，但不指定分配给哪个进程，当协程需要中断时，为其分配内核栈，及相应封装。

> 关于Pending，就目前而言，使用 async 关键字创建的异步块或异步函数，并不会在中途返回Pending然后等待被唤醒，只有手动实现 poll 函数的Future，才可以在其中的指定位置返回Pending然后等待被waker唤醒，也就是说，即是是很长的异步任务，也会一直执行，直到任务完成。
> 
> 目前yield关键字没有具体作用，有可能在后续版本中，可以在 async {} 使用 yield 来指定返回 Pending 的位置。
> 
> 这带来的影响是，基于现在的Rust版本，协程在任意位置让出，也需要保存上下文。
> 
> async自动创建的future， loop执行， 有什么办法能返回pending。成与不成，写个例子。

在传统的线程调度器中，线程通过函数栈执行线程的主（子）函数或系统调用（内核栈）；在协程调度器中，协程的执行不需要栈来保存执行内容（函数），执行内容就是future本身，但是，执行协程就是执行一个future的`poll`函数，这个过程中依然会有函数的嵌套调用，所以执行器执行的`task.future.poll()` 需要用到用户栈。

进入内核执行内核任务（中断服务例程），需要把内核任务Pin在一个内存地址中，类似与使用内核栈执行系统调用。 **问题3：如何把任务固定在该空间？**

答：参考tornado实现

# 任务窃取

多核情况下，每个处理器运行一个执行器执行任务，如果访问同一个任务队列，必然导致竞争频繁发生。如果每个执行器单独拥有一个队列，当任务队列为空时，从其他任务队列中窃取任务。

# 踩坑记录

## segmentaton fault

协程在就绪队列和阻塞队列之间移动时，要将`stack`固定在内存上，使得上下文中的`sp`指针可以始终指向对应的正确的位置，否则，移动之后，保存`stack`的vector已经是另一片内存空间，但是`sp`的内容不会改变，依然指向上一个vector。

而且，协程移动时不能简单地先复制后删除，复制协程会得到另一片固定在内存的vector，但不是`sp`指针指向的那个vector。

## thread_local

每个CPU执行一个运行时，所以每一个运行时属于一个CPU，运行时全局指针应设置为`thread_local`变量。否则，多个CPU将实际访问最后一个被init的运行时。

# 参考资料

## risc-v

### 特权级

- Machine：机器态，最高特权级，可以运行所有指令，一般用于运行bootloader

- Hypervisor：对虚拟机的支持

- Supervisor：监督态，运行内核

- User：用户态，运行应用程序

### 中断

risc-v使用`ecall`指令支持用户态到内核态的中断。主要作用是保存当前指令地址`pc`到`sepc`，并加载`pc`新值为指定地址，使得下一条指令跳转到指定函数执行。

> risc-v book 原文：
> 
>     The ECALL instruction is used to make a service request to the execution environment. The EEI（Excution Environment Interface）
> will define how parameters for the service request are passed, but usually these will be in defined locations in the integer register file.

#### ecall指令让硬件做的事

1. 如果陷阱是设备中断，且寄存器`sstatus`的**SIE位 = 0**，则不执行下面的任何步骤；
2. 设置**SIE位 = 0**，表示关闭中断；
3. 拷贝`pc`到`sepc`；
4. 将当前模式保存到`sstatus`中的**SPP位**（1为S，0为U）；
5. 设置`scause`来反映陷阱的原因；
6. 设置模式为内核模式；
7. 拷贝`stvec`到`pc`，即取出中断入口程序地址加载到pc；
8. 在新的`pc`处开始执行。

#### 硬件没有做的事

1. 切换页表为内核页表。

2. 切换为内核栈。

处理trap时，CPU硬件没有做的事，由内核来做。

#### CSR寄存器

- scause：S态trap原因寄存器，指出中断或是异常编号（exception code）。

- stvec：S态trap向量，[31:2]为中断处理函数的base地址，程序发生trap之后会将pc寄存器的值的高30位设置为这个地址。mtvec的最后两位指出trap模式：
  
  - 00：直接模式。
  
  - 01:向量模式，pc寄存器设置为 base + 4 * cause

- sepc：保存trap发生时的指令地址。

## [飓风OS](https://github.com/HUST-OS/tornado-os)

协作式调度、非实时系统。

### 用户态应用程序执行过程

将应用程序编译为二进制文件，并为其分配进程地址空间，加载到内存直接执行，不封装为Task，在应用程序中，可以使用共享调度器提供的接口，生成、执行task。

也就是说，应用程序不会被封装为task放到调度器中，也不在执行器的流程中执行，而是以二进制文件的方式直接在机器上运行。

这带来的问题时，当共享调度器中没有任务时，系统就会退出。**如果没有手动切换进入某进程的地址空间**，那么直到系统结束，该程序也不会被执行。

### 1.进程

传统的进程创建是从一个主函数开始，将这个函数加载为将要执行的主线程。但飓风OS取消了传统线程的概念，调度器处理的是来自各个地址空间的Task，进程的作用是隔断地址空间，保存Task。

进程这一概念更接近"地址空间映像"。

```rust
pub struct Process {
    /// 进程的编号
    id: ProcessId,
    /// 进程是否属于用户态进程
    is_user: bool,
    /// 地址空间
    inner: Mutex<ProcessInner>,
}

pub struct MemorySet {
    /// 本空间的页表和映射关系
    pub mapping: Mapping,
    /// 每个字段
    pub segments: Vec<Segment>,
    /// 所有分配的物理页面映射信息
    pub allocated_pairs: Vec<(VirtualPageNumber, FrameTracker)>,
    /// 这个映射关系的地址空间编号
    pub address_space_id: AddressSpaceId,
}
```

### 2.线程

硬件线程。

### 3.Task

调度器调度运行的实体，封装了一个future，即实际要执行的任务。

```rust
pub struct KernelTask {
    /// 任务的编号
    pub id: TaskId,
    /// 任务所属的进程
    pub process: Arc<Process>,
    /// 封装本任务运行的栈，初始为None,复用其他任务的栈
    pub inner: Mutex<TaskInner>,
    /// 任务的内容
    pub future: Mutex<Pin<Box<dyn Future<Output = ()> + 'static + Send + Sync>>>, // 用UnsafeCell代替Mutex会好一点
}

pub struct TaskInner {
    /// 本任务运行的栈，一段虚拟地址
    ///
    /// 内核任务复用执行器的栈。用户任务占有一个栈，下一个任务复用此栈。
    /// 强制中断暂停时，下一个任务使用新分配的栈。
    pub stack: Option<Range<VirtualAddress>>,
}
```

### 4.执行任务的方式

1. 创建任务
   
   ```rust
   let task1 = task::new_kernel{
       future, // 实际执行的任务
       进程,    // 任务所属的进程，以上二者会被打包为Task
       共享调度器, // ?????
       任务状态,
   }
   ```

2. 往调度器添加任务
   
   系统需要执行的future，实际经过了三层封装：
   
   future -> KernelTask(打包地址空间) -> KernelTaskRepr(打包调度器指针) ->
   
   TaskMeta(打包处理器编号)，最终将任务元数据插入到调度器的调度队列中。
   
   ```rust
   shared_payload.add_task(
                           硬件线程id,  // 处理器编号
                           地址空间id,
                           1.中创建的任务的指针
                          );
   
   pub struct TaskMeta {
       /// 运行此任务的硬件线程编号
       pub(crate) hart_id: usize,
       /// 地址空间的编号
       ///
       /// 内核地址空间编号是0，用户的地址空间编号从1开始增长
       pub(crate) address_space_id: AddressSpaceId,
       /// 元数据指针，由所在的地址空间解释
       task_repr: TaskRepr,
       /// 任务当前的状态
       pub(crate) state: TaskState,
   }
   ```

3. 执行任务
   
   如果是处于同一地址空间，可以直接执行任务的poll函数。否则，调用switch函数上下文，进入任务的地址空间。
   
   ```rust
   // 函数1: 调度器从任务队列弹出一个任务，根据是否属于当前地址空间，
   //       返回Task或下一个地址空间id
   // 函数2: 当任务返回Ready时调用，从任务队列中将其删除
   // 函数3: 将Task设置为指定状态
   async_rt::run_until_idle(函数1，函数2，函数3)
   ```

### 5.任务切换的方式

当下一个任务与当前任务不在同一地址空间（进程）时，调用switch函数切换地址空间与执行环境。

```rust
pub fn switch_to_user(
                      context: &SwapContext,
                      user_satp: usize, 
                      user_asid: usize
                     );
```

#### 切换到用户空间的过程：

1. 将应用程序编译为二进制文件（app.bin）。

2. 为进程分配地址空间，同时利用文件系统，将应用程序的二进制文件加载到该地址空间。
   
   ```rust
   async fn load_user(path: String) -> MemorySet {
       1. 获取新的地址空间编号
       2. 申请分配n个物理页面
       3. 将二进制文件放入刚申请的物理页面
       4. 将地址空间封装为MemorySet返回
   }
   ```

3. 在地址空间中，分配空闲物理页建立一些映射，创建上下文（页表基址satp，共享调度器地址gp，用户栈，寄存器值）。

以上三步封装在函数prepare中，注意到这个函数是一个async函数，会返回一个future，所以切换到用户空间的过程实际上是通过一个内核任务来完成的，所以使用的是内核的地址空间来执行此任务。当此任务完成，应用程序就成功加载到内存。

```rust
async fn prepare_user(path: String, kernel_stack_top: usize)
```

#### 上下文

```rust
pub struct SwapContext {
    // 用户栈起始地址保存于寄存器 sp，值存放于 x[1]
    pub x: [usize; 31], // 31个通用寄存器
    pub kernel_satp: usize, // 根页表始址，保存于RV的satp寄存器

    pub kernel_stack: usize, // 内核栈指针
    pub user_trap_handler: usize, // 陷入内核时的处理函数
    pub epc: usize, // sepc 寄存器
    pub kernel_tp: usize, // 内核 tp 寄存器的值
                          // tp: thread pointer
}
```

每个用户程序在切换时，将上下文保存在属于自己的一个页中，这个专属页是一个常量，用户程序通过 SWAP_FRAME_VA - 4KB*用户地址空间编号得到所属页的起始地址。 

![](https://github.com/oscourse-tsinghua/AsyncKernel2021-UserScheduler/tree/master/img_src/上下文地址空间.pgn)

### 6.中断响应流程

#### 用户态调用系统调用

经过两次跳转进入到内核的中断处理程序。第一次是`ecall`指令，从`stvec`中取出中断入口程序地址加载到`pc`，保存上下文，恢复内核栈、页表；第二次跳转是在入口程序末尾，通过`jr指令`跳转到上下文中保存的中断处理程序地址。

1. 用户进程 `do_yield(asid)` 系统调用；

2. 执行`ecall`指令，并通过汇编将中断参数传入寄存器`a6`，`a7`;

3. rv硬件工作：
   
   1. 保存当前`pc`到`sepc`；
   
   2. 设置`scause`反映中断原因：Interrupt or Exception；
   
   3. 从`stvec`取出中断处理入口程序地址加载到`pc`，这个入口程序是函数（一段汇编）`trap/swith.rs user_to_supervisor()`，作用是**保存当前进程的上下文，并换上内核栈和内核页表**。每次从内核态进入用户态时，都会设置`stvec`为这个函数的地址，位于内核地址空间中固定的位置；
   
   4. 从新`pc`处开始执行；

4. 中断第一次分发：从`scause`取出中断原因；

5. 中断第二次分发：根据中断原因与上下文中记录的`a6` 、`a7`中的中断参数，进入确定的中断处理函数。如果是`do_yield`系统调用，那么将交给 `syscall(···)`处理，从下一个任务的context中取出`satp`返回，然后将上一个进程的`sepc`寄存器 + 4，即原进程中`do_yield()`的下一条指令地址。

6. 执行`switch_to_user(next_asid)` 切换到指定进程运行。在这个函数中，会将next_asid写入`struct hart`硬件线程中。

`stvec`中的地址是一个常量`SWAP_FRAME_VA`，通过`link section = ".swap"`将该汇编函数链接到指定位置。

在tornado的设计中，硬件线程是对CPU的抽象，一个CPU只有一个硬件线程，用于指出占据当前CPU的进程（地址空间编号）。且在tornado中进程的context页地址是关于地址空间的线性函数，所以用户进程通过中断进入内核时，可以直接从`hart`中得到上一个进程的asid，进而得到其context。

简单来说，每个进程在内核地址空间的固定位置有一页用于保存context，内核初始化时会为每个CPU创建一个`hart`标记当前正在运行的进程，保存其asid，当用户进程陷入内核，可以根据`hart`得到该进程的上下文，从中取出传递到内核的中断处理的参数（用于说明需要内核做什么事）。  

## Linux内核

Linux内核中，将进程与线程不加区分的表示为 `struct task_struct`，线程仅仅被视为与某进程共享一些资源（主要是地址空间）的进程，是否共享地址空间，几乎是Linux中进程和线程间的唯一区别。

### 内核栈与用户栈

用户栈用于执行线程的任务函数，在用户态中，CPU的esp寄存器保存的是用户栈栈顶指针。

内核栈用于陷入内核，执行内核函数时使用。刚陷入内核和即将从内核返回时，内核栈为空。陷入内核时，要将用户栈栈顶指针压入内核栈，用于返回。

用户栈和内核栈就是不同特权级（用户态和内核态）下，线程执行函数的函数栈。

> 为什么不只用一个栈？
> 
>     系统调用等内核程序必须在内核态下执行，所以必须有内核栈。如果只保留内核栈，在内核栈的执行线程的任务函数，用户程序的不可预测性将带来极大的安全隐患。

## 执行器线程

[从头实现Rust异步执行器 :: steven的个人博客](https://stevenbai.top/rust/build_your_own_executor/)

# 新思路

线程被视为CPU的抽象，在一个loop循环中不断地从任务队列中取走协程执行。

为了统一进程切换与线程切换，每个线程确定从属于某个进程，当某一个线程

进程维护一个线程列表，进程初始化时创建一个空闲线程（线程从loop开始执行），进程切换时，只有当下一个进程没有就绪线程，才创建新的线程；如果空闲线程大于1个，删除。

系统中将维护两个线程列表：

1. 就绪线程列表：可以直接执行；

2. 阻塞线程列表：等待唤醒；

协程的waker，即唤醒方式，实现为将阻塞队列移到就绪队列；

```rust
// 启动运行时
fn run() {
    loop {
        if 就绪线程数 != 0 { 
            执行线程; 
        } else if 任务数 != 0 {
            创建一个新线程取走任务执行；
        } else if 阻塞线程数 == 0 {
            break ;
        } 
    }
}

// 线程主函数
fn thread_main() {
    loop {
        if 任务队列为空 { break; }

        从调度器取出一个协程;
        let ret = task.future.poll();

        if 协程未完成 {
            协程插回调度器;
        }
    }
}
```

```rust
fn main() {
    // 
    Coroutine::new(||{...});
}
```

一个物理CPU，单进程，不断地从任务队列取出任务执行。

协程1等待协程3唤醒，协程2执行到让出点主动让出，协程4正常执行结束

线程因为任务队列为空而返回运行时的`return`函数，在其中删除此线程，并重新启动运行时执行。
